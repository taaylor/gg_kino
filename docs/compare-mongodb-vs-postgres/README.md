# Исследование по выбору хранилища для данных о фильмах

## Цель исследования
Целью данного исследования является сравнение производительности двух баз данных — MongoDB и PostgreSQL — для хранения и обработки данных о закладках и оценках фильмов. Задача включает измерение скорости чтения данных и определение оптимального хранилища для указанных сценариев использования.

## Методология

### Выбор хранилища
Для исследования выбраны две базы данных:
- **MongoDB**: Документоориентированная NoSQL база данных, оптимизированная для горизонтального масштабирования.
- **PostgreSQL**: Реляционная база данных с поддержкой ACID-транзакций.

### Генерация данных
- Написан скрипт для генерации 10 миллионов записей в каждой базе данных.
- Данные включают информацию о закладках и оценках фильмов.

### Тестирование производительности
Тестирование проводилось на чтении уже загруженных данных. Проверялись следующие реальные кейсы:
- Средняя пользовательская оценка фильма.
- Список фильмов добавленных в закладки пользователем.

Для оценки производительности выполнено 200 запросов по заранее подготовленным ID. В MongoDB запросы выполнялись по полю `film_id`, которое является ключом шардирования.

### Конфигурация кластера
- **MongoDB**: Кластер с 2 шардами, 3 конфиг-серверами и одним mongos. Ключ шардирования установлен на поле `film_id`, что влияет на распределение данных и производительность запросов.
- **PostgreSQL**: Одиночный сервер (шардирование не применялось).

## Результаты

### Тестирование чтения по ID
Тестирование проводилось на 200 запросах для каждой базы данных. Результаты:

#### MongoDB
- **Среднее время запроса**: 0.0012 секунд.
- **Успешно найдено документов**: 200/200 (100.0%).
- **Общее количество документов в коллекции**: 10,000,000.

#### PostgreSQL
- **Среднее время запроса**: 0.0008 секунд.
- **Успешно найдено записей**: 200/200 (100.0%).
- **Общее количество строк в таблице**: 10,000,000.

### Сравнение производительности
- PostgreSQL оказался быстрее MongoDB в 1.53 раза (0.0012 сек / 0.0008 сек).
- MongoDB оказалась медленнее, несмотря на , что запросы выполнялись по ключу шардирования `film_id`. Это может указывать на проблемы с индексами, конфигурацией или структурой запросов.

## Выводы
- **PostgreSQL** демонстрирует более высокую производительность при чтении данных по ID, а также 100% успешность выполнения запросов.
- **MongoDB** показала более низкую производительность, что требует дополнительного анализа (например, проверки индексов или корректности тестовых данных).

## Выбор и обоснование решения

### Разработать отдельный сервис или добавить в существующий
Рассматривались два подхода:

#### Отдельный сервис
- **Преимущества**:
  - Изоляция логики и данных, что упрощает масштабирование и поддержку.
  - Подходит для задач с высокими требованиями к производительности и независимости.
- **Недостатки**:
  - Увеличивает сложность инфраструктуры и накладные расходы на управление.

#### Добавить в существующий сервис
- **Преимущества**:
  - Упрощает интеграцию с текущими функциями и уменьшает затраты на управление.
  - Подходит, если данные тесно связаны с существующими компонентами.
- **Недостатки**:
  - Может усложнить масштабирование и снизить гибкость.

### Причины выбора
- На основании результатов тестирования, **PostgreSQL** предпочтительнее для задач, где важна скорость чтения данных и надежность выполнения запросов.
- Если в будущем потребуется горизонтальное масштабирование, стоит рассмотреть **MongoDB**.
- На основе исследования принято решение разработать отдельный сервис, использующий MongoDB, из-за возможности горизонтального масштабирования.
- Окончательный выбор зависит от дополнительных факторов:
  - Требований к транзакциям и целостности данных (в пользу PostgreSQL).
  - Необходимости масштабирования и обработки больших объемов данных (в пользу MongoDB).

## Заключение
Исследование показало, что PostgreSQL превосходит MongoDB по скорости чтения данных (в 1.53 раза) и надежности выполнения запросов в текущей конфигурации. Однако более низкая производительность MongoDB, несмотря на использование ключа шардирования `film_id`, требует дополнительного анализа, чтобы исключить ошибки тестирования. На основе исследования было принято решение разработать отдельный сервис, использующий MongoDB, для возможности горизонтального масшатбирования, и как более подходящей СУБД для микросервиской архитектуры. Для принятия окончательного решения рекомендуется учесть специфику приложения.
